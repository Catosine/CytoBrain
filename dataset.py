# Made by Cyto
#     　　　　 ＿ ＿
# 　　　　　／＞　　 フ
# 　　　　　|   _　 _l
# 　 　　　／` ミ＿xノ
# 　　 　 /　　　 　 |
# 　　　 /　 ヽ　　 ﾉ
# 　 　 │　　|　|　|
# 　／￣|　　 |　|　|
# 　| (￣ヽ＿_ヽ_)__)
# 　＼二つ ；
import os
import os.path as osp
import re

import cv2
import numpy as np
from torch.utils.data import Dataset
from tqdm import tqdm


class Algonauts2023Raw(Dataset):
    """
        Load original data for Algonauts2023 dataset
    """

    def __init__(self, data_path: str, hemisphere: str = "L", transform=None, train: bool = True):
        """
            Initialize a torch.utils.data.Dataset object for algonauts2023 dataset

            Args:
                data_path,              str, path to the algonauts2023 dataset which contains only ONE subject
                hemisphere,             str, select which hemisphere of the brain to be modeled
                                            can ONLY select "L" or "R"
                                            and ONLY applicable when train is TRUE
                transform,              torchvision.transform methods, apply normalization to the dataset
                train,                  bool, training data will be loaded if True. Test data otherwise.
        """

        # collect data paths
        path_struct = osp.join(data_path, "{}_split")
        self.dataset = list()
        self.transform = transform
        self.train = train

        if train:
            shared_path = osp.join(
                path_struct.format("training"), "training_{}")
            if hemisphere == "L":
                self.fmri = np.load(osp.join(shared_path.format(
                    "fmri"), "lh_training_fmri.npy"))
            elif hemisphere == "R":
                self.fmri = np.load(osp.join(shared_path.format(
                    "fmri"), "rh_training_fmri.npy"))

            self.image_path = shared_path.format("images")
        
        else:
            self.image_path = osp.join(path_struct.format("test"), "test_images")
            
        self.dataset = list(os.listdir(self.image_path))

    def __len__(self):
        return len(self.dataset)

    def __getitem__(self, index: int):
        """
            Load designated sample

            Arg:
                index,          int, sample id

            Returns:
                image,          np.ndarray, the 3d numpy array of the image used to retrive fmri data
                fmri,           np.ndarray, the hemisphere FMRI data generated by the image
        """

        img_file = self.dataset[index]
        img_idx = int(re.findall("\d{4}", img_file)[0]) - 1

        img = cv2.imread(osp.join(self.image_path, img_file)).astype(np.float32)
        
        if self.transform:
            img = self.transform(img)
        
        #img = img.reshape(img.shape[2], img.shape[0], img.shape[1])

        return img, self.fmri[img_idx] if self.train else 0


if __name__ == "__main__":

    from utils import build_transform

    dataset = Algonauts2023Raw(
        "/Users/cytosine/Documents/Algonauts2023/data/subj08", train=False, transform=build_transform("subj08"))
    

    print("Successfully loaded")

    from torch.utils.data import DataLoader

    dataloader = DataLoader(dataset, batch_size=32, num_workers=2)

    nimages = 0
    mean = 0.
    std = 0.
    for batch, _ in tqdm(dataloader):

        # Rearrange batch to be the shape of [B, C, W * H]
        batch = batch.view(batch.size(0), batch.size(1), -1)
        # Update total number of images
        nimages += batch.size(0)
        # Compute mean and std here
        mean += batch.mean(2).sum(0)
        std += batch.std(2).sum(0)

    # Final step
    mean /= nimages
    std /= nimages

    print(mean)
    print(std)
